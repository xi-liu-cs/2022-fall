<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ray Tracing</title>
    <link rel="stylesheet" href="./lib/elementui.css">
    <link rel="stylesheet" href="./css/index.css">
    <script src="./lib/webgl-utils.js"></script>
    <script id="shader-fs" type="x-shader/x-fragment">
        precision highp float;
        const vec3 lightDir = vec3(0.577350269, 0.577350269, 0.577350269);
        const vec3 ambientColor = vec3(0.1, 0.3, 0.5);
        const vec3 diffuseColor = vec3(0.8, 0.5, 0.6);
        const vec3 specularColor = vec3(0.8, 0.8, 0.8);

        const vec4 fogColor = vec4(1.0, 1.0, 1.0, 1.0);

        const vec3 COLOR_BLACK = vec3(0.3, 0.3, 0.6);
        const vec3 COLOR_WHITE = vec3(0.5, 0.6, 0.7);

        // fog density(1.0, 2.5)
        uniform float uFogDensity;
        uniform bool uUseFog;
        uniform bool uReflectFloor;
        varying vec3 vPosition;
        uniform vec3 cameraPos;
        uniform vec3 sphere1Center;
        uniform bool uUseColor;
        uniform vec3 uColorValue;
        uniform bool uUseBackgroundColor;
        uniform vec3 uBackgroundColorValue;

        uniform vec4 uS[3];
        uniform vec3 uLd[2];
        uniform vec3 uLc[2];
        uniform vec3 uDc;
        varying vec3 vPos;
        float fl = 3.;

        float raySphere(vec3 V, vec3 W, vec4 S) {
            V -= S.xyz;
            float b = dot(V, W);
            float d = b * b - dot(V, V) + S.w * S.w;
            return d < 0. ? -1. : -b - sqrt(d);
        }

        vec3 shadeSphere(vec3 P, vec4 S) {
            vec3 N = normalize(P - S.xyz);
            vec3 c = vec3(.1,.1,.2);
            vec3 E = vec3(0.,0.,1.);
            for (int l = 0 ; l < 2 ; l++) {
      
               float t = -1.;
               for (int n = 0 ; n < 3 ; n++)
                  t = max(t, raySphere(P, uLd[l], uS[n]));
      
               float weight = step(t, 0.);
               if (t < 0.) {
                  vec3 R = 2. * dot(N, uLd[l]) * N - uLd[l];
                  c += weight * uLc[l] * (uDc * max(0.,dot(N, uLd[l]))
                             + pow(max(0., dot(R, E)), 20.));
               }
            }
            return c;
        }

        /* 线球求交*/
        bool intersectSphere(vec3 center, vec3 lStart, vec3 lDir, out float dist) {
            vec3 c = lStart - center;
            float b = dot(c, lDir);

            /**
            * 当球心和CameraPos的向量和Ray向量(方向相反)成钝角的时候，才显示到屏幕上
            */
            if (b > 0.0) {
                dist = 10000.0;
                return false;
            }
            /* radius:0.1 */
            // 射线和球求交   线上必有一点距离球心的距离是 R
            float d = b * b - dot(c, c) + 0.01 ;

            if (d < 0.0) {
                dist = 10000.0;
                return false;
            }
            // 求最短距离，所以sqrt前的符号为-
            dist = -b - sqrt(d);

            if (dist < 0.0) {
                dist = 10000.0;
                return false;
            }

            return true;
        }

        bool intersectPlane(vec3 lStart, vec3 lDir, out float dist) {
            
            vec3 normal = normalize(vec3(0.0, 1.0, 0.0));

            float a = dot(lDir, normal);

            if (a > 0.0) {
                dist = 10000.0;
                return false;
            }

            float b = dot(normal, lStart - vec3(0.0, 0.0, 0.0));

            dist = -b / a;

            return true;
        }

        bool intersectWorld(vec3 lStart, vec3 lDir, out vec3 pos, out vec3 normal, out vec3 color, out float distance, out bool isFloor) {
            
            //float distance;

            if (intersectSphere(sphere1Center, lStart, lDir, distance)) {
                pos = lStart + distance * lDir;
                normal = normalize(pos - sphere1Center);

                // *************
                // diffuse light
                // *************
                float diffuseWighting = max(dot(normalize(lightDir), normal), 0.0);

                // *************
                // specular light
                // *************
                vec3 eyeDirection = normalize(-vPosition.xyz);
                vec3 reflectionDirection = reflect(-lightDir, normal);

                // factor: 32
                float specularLightWeighting = pow(max(dot(reflectionDirection, eyeDirection), 0.0), 32.0);
                if(uUseColor){
                   color = uColorValue;
                }else {
                    color = ambientColor + diffuseWighting * diffuseColor + specularLightWeighting * specularColor;
                }
                
                isFloor = false;
                
                return true;
            } else if (intersectPlane(lStart, lDir, distance)) {

                pos = lStart + distance * lDir;

                float scale = 6.0;
                if(uUseBackgroundColor){
                    color = uBackgroundColorValue;
                }else {
                    color = mod(abs(floor(pos.x * scale) + floor(pos.z * scale)), 2.0) < 1.0 ? COLOR_BLACK : COLOR_WHITE;      
                }

                // 地板反射,改变法线向量
                normal = vec3(0.0, 1.0, 0.0);
                
                isFloor = true;
                
                return true;
            } else {
                // 雾模式下，天空会出现溢出，所以在这里将pos.z设置为-1，这样既不会太白，也不会太黑
                pos = vec3(0.0, 0.0, -4.0);
                return false;
            }
            
        }

        void main(void) {
            vec3 V = vec3(0.,0.,fl);
            vec3 W = normalize(vPosition -fl);
            float tMin = 10000.;

            vec3 cameraDir = normalize(vPosition - cameraPos);
            float pointDistance;
            float distance;
            vec3 color,normal,pos1, pos2, pos3;
            vec3 colorM, colorR;
            bool isFloor;
            if (intersectWorld(cameraPos, cameraDir, pos1, normal, color, pointDistance, isFloor)) {
                
                
                if (!isFloor || uReflectFloor) {     // 启用反射后的效果
                
                    vec3 cameraDir2 = reflect(cameraDir, normal);
                    
                    if (intersectWorld(pos1, cameraDir2, pos2, normal, colorM, distance, isFloor)) {
                    
                        // only reflect light that distance <= 1.5.
                        
                        if (distance <= 1.5) {
                        
                            // 如果是从白色地板反射到球上的，那么使用加法不足以计算颜色。因为超过1.0的还是白色。所以只能用乘法。
                            // f(x) = x / (1 + x)是增函数，x越大，y越大.y越大，则颜色越浅
                            for (int n = 0 ; n < 3 ; n++) {
                                float t = raySphere(V, W, uS[n]);
                                if (t > 0. && t < tMin) {
                                   color = shadeSphere(V + t * W, uS[n]);
                                   tMin = t;
                                }
                            }
                            
                            color *= ((colorM + vec3(0.7)) / 1.7);

                            vec3 cameraDir3 = reflect(cameraDir2, normal);
                            
                            // 计算地板反射到球上，并由球反射到地板的光线
                            if (!isFloor && intersectWorld(pos2, cameraDir3, pos3, normal, colorR, distance, isFloor)) {
                                color = colorR * 0.05 + colorM * 0.4 + color * 0.55;
                            }
                        }
                        
                    }
                
                }
            } else {
                color = COLOR_BLACK;
            }

            if (uUseFog) {
                // fogFactor = e^-(z * density)
                // we must change from pos1.z is (-1, 1) to (-1, 0)
                // (result - (-1)) / (0 - (-1)) = (pos.z - (-1)) / 1 - (-1) => result = (pos.z - 1) / 2
                
                // clamp负责雾化公式的计算。保证最近的物体可以被看清，最远的物体完全看不见。
                // clamp保证第一个参数会在第2-3两个参数的区间范围内
                float fogFactor = clamp(exp(((pos1.z - 1.0) / 2.0) * uFogDensity), 0.0, 1.0);//clamp((2.0 - pointDistance) / 2.0, 0.0, 1.0);

                gl_FragColor = mix(fogColor, vec4(color, 1.0), fogFactor);
            } else {
                gl_FragColor = vec4(color, 1.0);
            }
        }
    </script>
    <script id="shader-vs" type="x-shader/x-vertex">
        attribute vec2 aVertexPosition;
        attribute vec3 aPlotPosition;
        varying vec3 vPosition;
        void main(void) {
            gl_Position = vec4(aVertexPosition, 1.0, 1.0);
            vPosition = aPlotPosition;
        }
    </script>
    <script src="./scripts/vector.js" type="text/javascript"></script>
    <script src="./scripts/main.js"></script>
</head>
<body>
    <div id="app">
        <el-container>
            <el-header class="ui-header">
                <h2>Ray Tracing</h2>
            </el-header>
            <el-main class="ui-main">
                <el-row :gutter="20">
                  <el-col :span="16" class="ui-main-canvas">
                    <canvas id="canvas" width="800" height="500">
                        哈哈哈哈，您的浏览器好老啊，更新去吧
                    </canvas>
                  </el-col>
                  <el-col :span="8" class="ui-tool-panel">
                    <fieldset class="ui-control-panel">
                    <legend>Control Panel</legend>
                    <el-form :label-position="labelPosition" label-width="120px" :model="form">
                        <el-form-item label="Effect">
                                <el-checkbox label="Reflect floor" id="reflectFloor" checked></el-checkbox>
                                <el-checkbox label="Use Fog" id="useFog"></el-checkbox>
                                <el-checkbox label="Use Color" id="useColor"></el-checkbox>
                                <el-checkbox label="BackgoundColor" id="useBackgroundColor"></el-checkbox>
                        </el-form-item>
                        <el-form-item label="Fog Density">
                            <input type="range" min="0" max="2.5" step="0.1" id="fogDensityRange" :value="form.fogDensity" oninput="document.getElementById('LabelValueFogDensityRange').innerHTML = this.value"/>
                            <label id="LabelValueFogDensityRange" class="labelValue">{{form.fogDensity}}</label>
                        </el-form-item>
                        <el-form-item label="View(Up/Down)">
                            <input type="range" min="0.1" max="1" step="0.01" id="viewPointRange" :value="form.viewPoint" oninput="document.getElementById('LabelValueViewPointRange').innerHTML = this.value"/>
                            <label id="LabelValueViewPointRange" class="labelValue">{{form.viewPoint}}</label>
                        </el-form-item>
                        <el-form-item label="Red">
                            <input type="range" id="red" min="0" max="100" step="1" :value="form.red" oninput="document.getElementById('LabelValueRedColor').innerHTML = (this.value/100).toFixed(1)"/>
                            <label id="LabelValueRedColor" class="labelValue">{{(form.red/100).toFixed(1)}}</label>
                        </el-form-item>
                        <el-form-item label="Green">
                            <input type="range" id="green" min="0" max="100" step="1" :value="form.green" oninput="document.getElementById('LabelValueGreenColor').innerHTML = (this.value/100).toFixed(1)"/>
                            <label id="LabelValueGreenColor" class="labelValue">{{(form.green/100).toFixed(1)}}</label>
                        </el-form-item>
                        <el-form-item label="Blue">
                            <input type="range" id="blue" min="0" max="100" step="1" :value="form.blue" oninput="document.getElementById('LabelValueBlueColor').innerHTML = (this.value/100).toFixed(1)"/>
                            <label id="LabelValueBlueColor" class="labelValue">{{(form.blue/100).toFixed(1)}}</label>
                        </el-form-item>
                    </el-form>
                    <p class="c-gray">You can also move camera by keydown/up/left/right.</p>
                    </fieldset>
                  </el-col>
                </el-row>
            </el-main>
        </el-container>
    </div>
    
    <script src="./lib/vue.js"></script>
    <script src="./lib/elementui.js"></script>
    <script>
        window.onload = function() {
            webGLStart();
            drawScene();
        }
    </script>
    <script>
        new Vue({
            el: '#app',
            data: function() {
                return {
                    labelPosition: 'left',
                    form: {
                        fogDensity: 2.0,
                        viewPoint: 0.4,
                        red: 20,
                        green: 30,
                        blue: 40
                    }
                }
            },
        })
    </script>
</body>
</html>